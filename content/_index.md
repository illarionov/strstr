---
title: Двусторонний алгоритм 
description: Двусторонний алгоритм поиска подстроки в строке
bookToc: true
bookFlatSection: false
date: 2022-05-24T09:32:31+03:00
draft: false
type: docs
math: true q
aliases: [
  "/docs/twoway/"
]
weight: 1
---

# Двусторонний алгоритм

**Двусторонний алгоритм** (англ. *Two-Way String-Matching algorithm*) — алгоритм поиска
подстроки в строке, разработанный и представленный Максимом Крочемором (Maxime Crochemore)
и Домиником Перреном (Dominique Perrin) в 1991 году.[^1] Относится к группе алгоритмов
поиска подстроки с ограниченным потреблением памяти, константным на практике
(constant-space string matching).

По заданной строке *Text* длины *n* и шаблону поиска *Pattern* длины *m* алгоритм
позволяет найти все вхождения *Pattern* в *Text* за время $O(n+m)$, где $O(m)$ — этап
предварительных вычислений над шаблоном, а $O(n)$ — этап поиска. При этом, во время поиска
выполняется не более $2n-m$ операций сравнения.

В отличие от алгоритмов Кнута-Морриса-Пратта и Бойера-Мура, данный алгоритм требует
$O(\log(m))$ памяти: на этапе препроцессинга строка шаблона разбивается на 2 подстроки и
хранится только позиция этого разбиения. Численное значение этой позиции меньше длины
шаблона $m$, поэтому требование по памяти может быть представлено как $\lceil\log_2
m\rceil$ бит и на практике может быть взято за $O(1)$.

Другое отличие данного алгоритма заключается в том, что ему требуется упорядоченный
алфавит, так как во время препроцессинга символы сравниваются на больше / меньше.

Алгоритм в целом считается достаточно эффективным и благодаря тому, что потребление памяти
практически не зависит от длины текста или шаблона, он используется в реализациях функций
`strstr()`, `memem()` некоторых вариантов библиотек libc: [glibc], [newlib] [musl] при
достаточно длинной строке шаблона.

## Общая схема

Сканирование строки на этапе поиска двустороннего алгортима похоже на сканирование в
примитивном алгоритме, алгоритмах Кнута-Морриса-Пратта и Бойера-Мура.

В алгоритме Кнута-Морриса-Пратта строка сканируется слева направо, сравнение символов
шаблона с символами текста также выполняется слева направо. Когда происходит несовпадение
в какой-то позиции шаблона (либо все символы шаблона равны и найдено вхождение), шаблон
сдвигается вправо на несколько позиций по заранее вычисленной таблице сдвигов паттернов
поиска.
TODO

```goat
          .---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---.                                  
          | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |16 |17 |18 |19 |20 |

          .-----------------------------------------------------------------------------------.
    Text: | A   B   C       A   B   C   D   A   B       A   B   C   D   A   B   C   D   A   B |
          '-----------------------------------------------------------------------------------'
                             сканирование
            ✔   ✔   ✔   ✘   --------------->
           .--------------------------.
Pattern₁: | A   B   C   D   A   B   D  |
           '+-------------------------'
            |
            |           ✘
            | Сдвиг    .--------------------------.
Pattern₂:   '-------->| A   B   C   D   A   B   D  |
                       +--------------------------'

                            ✔   ✔   ✔   ✔   ✔   ✔   ✘
                           .--------------------------.
Pattern₃:                 | A   B   C   D   A   B   D  |
                           '--------------------------'


                          Сканирование строки в алгоритме Кнута-Морриса-Пратта
```

В алгоритме Бойера-Мура строка также сканируется слева направо, но символы шаблона
сравниваются справа налево. При встрече несовпадающего символа, шаблон сдвигается на
смещение, которое вычисляется как максимальное по 2 эвристикам: правилу сдвига плохого
символа и правилу хорошего суффикса.

```goat
          .---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---.                                  
          | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |16 |17 |18 |19 |20 |

          .-----------------------------------------------------------------------------------.
    Text: | A   B   A   B   C   X   F   D   E   D   E   A   X   A   A   B   C   D   E   B   C |
          '-----------------------------------------------------------------------------------'
                   сканирование
                 <---------------   ✘   ✔   ✔
           .---------------------------------.
Pattern₁: | A   B   C   X   A   B   C   D   E |
           '+------------------------------+-'
            |
            |                                                           ✘
            |    Сдвиг                 .----------------------------------.
Pattern₂:   '------------------------>| A   B   C   X   A   B   C   D   E  |
                                       '+---------------------------------'

                                                                ✘   ✔   ✔   ✔   ✔   ✔
                                                   .----------------------------------.
Pattern₃:                                         | A   B   C   X   A   B   C   D   E  |
                                                   '+---------------------------------'

                           Сканирование строки в алгоритме Бойера-Мура
```

В двустороннем алгоритме строка шаблона делится на 2 подстроки: $u$ и $v$. Сначала
сравнивается правая подстрока $v$ слева направо, затем, если все символы правой подстроки
совпали, то сравнивается левая подстрока $u$ справа налево. Если встречается несовпадающий
символ, то шаблон сдвигается вправо на некоторое количество позиций. Правила сдвигов при
несовпадении разные для правой и левой части разбиения. Величина сдвига вычисляется за
константное время и константную память.

```goat
          .---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---.                                  
          | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |16 |17 |18 |19 |20 |

          .-----------------------------------------------------------------------------------.
    Text: | E   B   C   D   A   C   D   A   B   D   A   B   C   D   A   B   D   D   A   B   D |
          '-----------------------------------------------------------------------------------'

            2. левая    1. правая часть
           <---------- ---------------->
                        ✔   ✔   ✘
           .--------------------------. 
Pattern₁: | A   B   C | D   A   B   D  +
           '+---------+---------------'
            |
            |               ✘   ✔   ✔   ✔   ✔   ✔
            | сдвиг    .--------------------------. 
Pattern₂:   '-------->| A   B   C | D   A   B   D  +
                       '+---------+---------------'

                                                        ✘
                                           .--------------------------. 
Pattern₃:                                 | A   B   C | D   A   B   D  +
                                           '+---------+---------------'


                       Сканирование строки в двустороннем алгоритме
                      (шаблон ABCDABD разбит на подстроки [ABC][DABD])
```

Общую схему для сканирования можно представить следующим псевдокодом:

```kotlin
fun stringMatching(text, pattern): Boolean {
    val n = text.length
    val m = pattern.length
    val (u, v) = factorize(pattern)

    var pos = 0, i = u.length
    while (pos <= n-m) {
        // Сравнение правой части
        while (i < m && pattern[i] == text[pos + i]) i += 1

        if (i == m) {
            // Сравнение левой части
            if (text.substring(pos .. pos + u.lastIndex) == u) {
                return true
            }
        }
        (pos, i) = shift(pos, i)
    }
    return false
}
```

`factorize()` — функция разбиения шаблона на 2 подстроки.
Двусторонний алгоритм использует разбиение шаблона на подстроки, называемый *критическим
разбиением* (*critical factorization*) и базируется на теореме о критическом разбиении
(*Critical Factorization Theorem*).  
`shift()` — правила сдвигов.
Двусторонний алгоритм выбирает разбиение строки $x = uv$, такое, что длина левой
подстроки $u$ меньше глобального периода всей строки шаблона ($|u| < per(x)$), длина $u$
минимальна, а правая подстрока $v$ периодична.

## Базовые понятия

Зададим некоторые базовые определения, связанные со строками, которые понадобятся в
описании алгоритма.

__Алфафит (*alphabet*)__

:   Конечное непустое множество символов. Обозначим его через $A$. Примеры наиболее часто
используемых алфавитов:

    * $A = \\\{\text{a,b,…, z}\\\}$ — множество строчных букв английского алфавита
    * $A = \\\{\text{0,1,2,3,4,5,6,7,8,9}\\\}$ —  множество цифр
    * $A = \\\{\text{0,1}\\\}$: бинарный алфавит

     и т.п.

__Строка (*texts, words, strings*)__

:   Конечная последовательность символов из некоторого алфавита $A$.  Длина текста — это
количество элементов в последовательности. Например, длина слова "$\tt{ABCDEF}$" равна 6.  
    Введем следующие обозначения для некоторый строки $x$:  
    $|x|$ ­— длина строки $x$.  
    $x[i]$ — $(i+1)$-ый символ строки (считаем, что первый символ находится по индексу 0).  
    $x[i…j]$ — подстрока $x[i]x[i+1]…x[j]$ строки $x$.

   Пустую строку обозначим через $ε$. Множество всех последовательностей алфавита $A$ —
   через $A^\*$, а множество всех непустых слов — через $A^\+$.

__Подстрока (*factor*, *subword*)__

:    Строка $x$ длины $n$ является *подстрокой* (или *фактором*) строки $y$, если $x=y[i …
i+n-1]$ для некоторого целого $i$. Мы можем говорить, что подстрока $x$ встречается в
строке $y$ в позиции $i$. Стоит отметить, что подстрока — это не то же самое, что и
*подпоследовательность* (*subsequence*).  
     Строка $x$ является *подпоследовательностью* строки $y$, если она может
быть получена удалением из $y$ нуля или более (не обязательно смежных) символов. Другими
словами, если $x=y[i₁]y[i₂]…y[i_m]$, где $i₁, i₂, i_m$ — увеличивающаяся
последовательность индексов строки $y$.

__Конкатенация и операции над текстом__

:    *Конкатенацией* двух строк $x$ и $y$ называют строку с последовательной записью их
символов. Обозначим конкатенацию строк $x$ и $y$ как $xy$. Например, если
$x=\tt{AB}, y=\tt{CD}$, то $xy=\tt{ABCD}$.  
  Через $k^x$ обозначим конкатенацию $k$ копий строки $x$. Например, для <nobr>$x=\tt{AB}$</nobr>, <nobr>$x⁴=\tt{\underlinesegment{AB}\underlinesegment{AB}\underlinesegment{AB}\underlinesegment{AB}}$</nobr>.
  Стоит отметить, что конкатенация ассоциативна, т.е. $(xy)z = x(yz)$, поэтому скобки здесь не
  обязательны и выражение можно записать как $xyz$.

  Рассмотрим строку $x = uvw$, представляющую из себя композицию из 3 подстрок: $u$, $v$ и
  $w$. Подстроки $u$, $v$ и $w$ называются *факторами* (*factors*)
  строки $x$. Кроме того:  
  $u$ — это *префикс* строки $x$,  
  $w$ — это *суффикс* строки $x$.

__Префикс (*prefix*)__

:   Строка $u$ называется *префиксом* строки $x$, если существует такая строка $v$, что
<nobr>$x=uv$</nobr>. Например, $\tt ABC$ — это префикс строки $\tt \underlinesegment{ABC}DAB$. 
    Префикс можно рассматривать как особый случай подстроки. Обычный префикс может быть как
    пустой строкой (ε), так и всей строкой.  
    *Собственный префикс* (*proper prefix*) — это префикс с дополнительными ограничениями:
    он не может быть пустым и не может быть равен всей строке целиком.

__Суффикс (*suffix*)__

:   Строка $w$ называется *суффиксом* строки $x$, если существует такая строка $v$, что
    <nobr>$x=vw$</nobr>. Например, $\tt DAB$ — суффикс строки $\tt ABC\underlinesegment{DAB}$.
    Также, как и в случае с префиксом, обычный суффикс может быть как пустым, так и всей
    строкой.  
    *Собственный суффикс* (*proper suffix*) — это суффикс, который не может быть
    равен пустой строке и всей строке целиком.

__Период (*period*)__

:   *Период* строки $x$ — это целое число $p$, $1<p≤|x|$ такое, что $$∀i∈\\{0,1,…|x|-p-1\\}
x[i]=x[i+p]$$
   Проще говоря, это длина постоянно повторяющегося фрагмента текста, причем,
   последнее вхождение может быть "обрезано". Например, строка $\tt{AABAAABAA}$ (её длина
   равна 9), имеет периоды 4, 7, 8 и 9:

    $$\begin{aligned}
        & \tt{\large{\underbrace{AABA}_4\underbrace{AABA}\underbrace{A\phantom{ABA}}}} \\\\
        & \tt{\large{\underbrace{AABAAAB}_7\underbrace{AA\phantom{BAAAB}}}} \\\\
        & \tt{\large{\underbrace{AABAAABA}_8\underbrace{A\phantom{ABAAABA}}}} \\\\
        & \tt{\large{\underbrace{AABAAABAA}_9}}
      \end{aligned}$$

   Отметим, что длина строки всегда является её периодом, а это значит, что любой строки
   всегда есть хотя бы один период.  
   Обозначим *наименьший период* строки $x$ через $per(x)$ (численное значение), а саму
   подстроку наименьшего периода — через $period(x)$.

  Возьмем непустую строку $x$ и какое-то число $p$ такое, что $0<p≤|x|$. Во всех следующих
случаях $p$ будет периодом строки $x$:

   1) Если $x$ — это подстрока некоторой строки $y^k$, где $|y|=p$ и $k>0$.  
      __Пример:__  
      $y^k=\underbrace{\texttt{ABC}}_y\underbrace{\tt{ABC}}_y\underbrace{\texttt{ABC}}_y\underbrace{\texttt{ABC}}_y$;  
      $y=\texttt{ABC}$  
      $p=3$  
      $k=4$  
      Если взять за $x$ любой префикс или подстроку (фактор) строки $y^k$, то один из её
      периодов будет тоже 3.

   1) Если строку $x$ можно представить как $(uv)^ku$, где $|uv|=p$, строка $v$ — непустая и $k>0$  
     __Пример:__  
     $x = \underbrace{\texttt{ABC}}_u\underbrace{\texttt{DEFG}}_v\underbrace{\texttt{ABC}}_u\underbrace{\texttt{DEFG}}_v\underbrace{\texttt{ABC}}_u$  
     $u=\texttt{ABC}$, $v=\texttt{DEFG}$  
     $x=(uv)²u$  
     $|uv|=7$, $p=7$

   1) Возьмем некоторые строки $y$, $z$ равной длины и строку $w$, такие, что
     <nobr>$x=yw=wz$; $|y|=|z|$</nobr>. В этом случе длина $y$ и $z$ будет периодом строки
     <nobr>$x$: $|y|=|z|=p$</nobr>.  
     __Пример:__  
      $x=\mathrlap{
        \overbrace{\phantom{\mathtt{ABCDAB}}}^w
        \overbrace{\phantom{\mathtt{ABCD}}}^z
      } \underbrace{\mathtt{ABCD}}_y\underbrace{\mathtt{ABCDAB}}_w
      $  
      $y=\tt ABCD$  
      $z=\tt CDAB$  
      $w=\tt ABCDAB$  
      $p=|y|=|z|=4$

__Грань (*border*)__

:   *Грань* (*граница* или *бордер*) строки $x$ — это любой собственный префикс строки, который
равен её суффиксу. Т.е. это грань — это такая строка $w$, что $x=yw=wz$.  Грань не может
быть равна всей строке, но суффикс и префикс строки могут быть перекрывающимися. Например,
грани слова $\tt AABAAABAA$: $\tt AABAA, AA, A, ε$.

    Обозначим наибольшую грань слова $x$ через $Border(x)$. Мы можем рассматривать такую грань
    как наибольшее совпадающее пересечение при наложении слова самого на себя.  
    Строка $x$ *свободна от граней* (*border free*), если наибольшая грань слова — это пустая
    строка, или другими словами, если наименьший период равен длине строки ($per(x)=|x|$)  
    Между гранями и периодами имеется взаимно однозначное соответствие, это можно увидеть по
    пункту 3 из описания периода.

    ```goat
      .----------------+-------------------------------------.                                                                   
    x |                |            Грань x                  |
      '----------------+-------------------------------------+
        <------------> |                                     +
           Период x    +-------------------------------------+----------------.
                     x |            Грань x                  |                |
                       '-------------------------------------+----------------'
    ```

## Описание алгоритма

Пусть $x$ — непустая строка, а $uv$ — разбиение $x$. Обозначим через $l$ длину левой части
разбиения минус 1 ($|u| - 1$). $0≤l<|x|$.  
Непустая строка $w$ называется *повторением для разбиения* $uv$ (*repetition for
factorization*) или *повторением в позиции $l$ строки $x$*, если выполняются оба условия:

* $w$ — суффикс $u$ или $u$ — суффикс $w$
* $w$ — префикс $v$ или $v$ — префикс $w$

Базовый случай повторения ($w$ — суффикс $u$ и $w$ — префикс $v$) — это когда разбиение
между $u$ и $v$ — это центр квадрата где-то в строке $x$:

```goat
      .---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---.                                      
      | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |16 |17 |18 |19 |20 |

      .-------------------+---+-----------+---+---------------+--+-----------------------.
    x |                   |   |           |   |               |  |                       |
      '-------------------+---+-----------+---+---------------+--+-----------------------+
                          |l-r             l                  l+r|
                          |                                      |
                          .-------------------+------------------.
                          |         𝒘         |        𝒘         |
                          '-------------------+------------------'

        <------------------------------------> <---------------------------------------->
                         𝒖                                         𝒗
```

Другие случаи соответствуют ситуациям, когда $l$ находится близко к краям строки или при
переполнении $w$. Стоит заметить, что если есть строка $x=uv$, а в качестве $w$ взять
строку $vu$, то эта строка $w$ будет повторением для разбиения $uv$ (выполнятся оба
условия). Т.е. любое разбиение непустой строки $x$ всегда имеет хотя бы одно повторение.

Длина $r$ повторения для разбиения $uv$ называется *локальным периодом $uv$* или
*локальным периодом строки $x$ в позиции $l$*.
Другими словами, число $r$ является *локальным периодом строки $x$ в позиции $l$*, если
$x[i]=x[i+r]$ для всех индексов $l-r+1≤i≤l$ и выполняются оба условия повторения.

Наименьшее возможное значение локального периода для разбиения $uv$ обозначается как
$r(u,v)$.

__Примеры__

Пусть строка $x=\texttt{ABAABAA}$.

Рассмотрим наименьший локальный период в позиции $l=2$:

$$
  \gdef\string_idx#1{\color{aaaaaa} \tt #1}
  \mathrlap{
    \overbrace{\phantom{
       \def\arraystretch{1.3}\begin{array}{c c c} \string_idx{0} & \string_idx{1} & \tt 2 \\\\
        \tt A & \tt B & \tt A
       \end{array}
      }
      \hspace{0.4em}
    }^u
    \overbrace{\phantom{
       \def\arraystretch{1.3}\begin{array}{c c c c} \string_idx{3} & \string_idx{4} & \string_idx{5} & \string_idx{6}
       \\\\ A & A & B & A
       \end{array}
      }
    }^v
  } \def\arraystretch{1.3}\begin{array}{c:c:c|c:c:c:c} \tt
    \string_idx{0} & \string_idx{1} & \tt 2 & \string_idx{3} & \string_idx{4} & \string_idx{5} & \string_idx{6} \\\\ \hdashline
    \tt A & \tt B & \tt \underlinesegment{A} & \tt \underlinesegment{A} & \tt B & \tt A &
    \tt A
  \end{array}
$$

$r(\texttt{ABA}, \texttt{ABAA}) = |\texttt{A}| = 1$,  
наименьшее повторение $w=\texttt{A}$.

Рассмотрим наименьший локальный период в позиции $l=1$:

$$ \mathrlap{
   \underbrace{
    \hspace{0.5em}
    \phantom{
      \def\arraystretch{1.3}\begin{array}{c}
        \string_idx{0} 1 \\\\
            \tt A & \tt B
      \end{array}
    }
   }_w
   \underbrace{
    \phantom{
       \def\arraystretch{1.3}\begin{array}{c c c}
          \string_idx{2} \string_idx{3} \string_idx{4} \\\\
           \tt A & \tt A \tt B
          \end{array}
    }
   }_w
  } \hspace{1em}
    \def\arraystretch{1.3}\begin{array}{c:c|c:c:c:c:c}
      \string_idx{0} & 1 & \string_idx{2} & \string_idx{3} & \string_idx{4} &
      \string_idx{5} & \string_idx{6} \\\\
      \hdashline
      \tt A & \tt B & \tt A & \tt A & \tt B & \tt A & \tt A
    \end{array}
$$

$r(\texttt{AB}, \texttt{AABAA}) = |\texttt{AAB}| = 3$,  
наименьшее повторение $w=\texttt{AAB}$.

Пусть строка $x=\tt AABABAB$

Рассмотрим наименьший локальный период в позиции $l=5$:

$$ \mathrlap{
   \hphantom{
    \def\arraystretch{1.3}\begin{array}{c c c c}
      \string_idx{0} & \string_idx{1} & \string_idx{2} & \string_idx{3}
      \end{array}
   }
   \underbrace{
    \phantom{
      \def\arraystretch{1.3}\begin{array}{c c}
        \string_idx{4} \\\\
            \tt B & \tt \hspace{0.6em}
      \end{array}
    }
   }_w
   \underbrace{
    \phantom{
       \def\arraystretch{1.3}\begin{array}{c}
          \string_idx{6} \\\\
           \tt B
          \end{array}
       \hspace{0.6em}
    }
   }_w
  } \def\arraystretch{1.3}\begin{array}{c:c:c:c:c:c|c}
      \string_idx{0} & \string_idx{1} & \string_idx{2} & \string_idx{3} & \string_idx{4} &
      \texttt{5} & \string_idx{6} \\\\
      \hdashline
      \tt A & \tt A & \tt B & \tt A & \tt B & \tt A & \tt B
    \end{array}
$$

$r(\texttt{AABABA}, \texttt{B}) = |\texttt{BA}| = 2$,  
наименьшее повторение $w=\texttt{BA}$.

Рассмотрим наименьший локальный период позиции $l=1$:

$$ \mathrlap{
   \underbrace{
    \phantom{
      \def\arraystretch{1.3}\begin{array}{c c c c c}
        \string_idx{3} \string_idx{2} \string_idx{1} \string_idx{0} 1 \\\\
            \tt B & \tt A & \tt B & \tt A & \tt A
      \end{array}
    }
   }_w
   \underbrace{
    \phantom{
       \def\arraystretch{1.3}\begin{array}{c c c c c}
          \string_idx{2} \string_idx{3} \string_idx{4} \string_idx{5} \string_idx{6}\\\\
           \tt B & \tt A & \tt B & \tt A & \tt B
          \end{array}
    }
   }_w
  } \hspace{6.6em}
    \def\arraystretch{1.3}\begin{array}{c:c|c:c:c:c:c}
      \string_idx{0} & 1 & \string_idx{2} & \string_idx{3} & \string_idx{4} &
      \string_idx{5} & \string_idx{6} \\\\
      \hdashline
      \tt A & \tt A & \tt B & \tt A & \tt B & \tt A & \tt B
    \end{array}
$$

$r(\texttt{AA}, \texttt{BABAB}) = |\tt BABABAA| = 7$,  
наименьшее повторение $w=\texttt{BABABAA}$.

Наименьший локальный период разбиения $x=uv$ не может быть больше глобального
периода строки: $1≤r(u,v)≤v$, это следует из определений.

Разбиение $x=uv$, при котором наименьший локальный период равен глобальному периоду всей
строки $r(u,v)=per(x)$ называется *критическим разбиением (critical
factorization)*, а позиция $l=|u|-1$ — *критической позицией $x$ (critical position)*.

### Теорема о критическом разбиении

Теорема гласит, что любая строка $x$ имеет хотя бы одно критическое разбиение $x=uv$ (т.е.
такое разбиение, что $r(u,v)=per(x)$).  Более того, подстрока $u$ может быть выбрана
такой, что её длина будет меньше глобального периода строки $x$: $|u|<per(x)$.

**Пример**

Пусть $x=\tt \underlinesegment{AABABAB}AAB$.  
Глобальный период строки $x$: 7 ($\tt AABABAB$)  
Локальные периоды для каждой позиции разбиения показаны в следующей таблице:

$$\def\arraystretch{1.3}\begin{array}{r|c:c:c:c:c:c:c:c:c:c}
  \text{Строка} & \tt A & \tt A & \tt B & \tt A & \tt B & \tt A & \tt B & \tt A & \tt A
  & \tt B \\\\ \hdashline
  \text{Позиция разбиения }l & 0 & 1 & 2 & 3 & 4 & 5 & 6 &
  7 & 8 & 9 \\\\ \hdashline
  \text{Лок. период }r(u,v) & 1 & \underline{7} & 2 & 2 & 2 & 2 & \underline{7} & 1 & 3 & 1
\end{array}
$$

Критические разбиения: $(\texttt{AA}, \texttt{BABABAAB})$ и $(\texttt{AABABAB}, \texttt{AAB})$.

В двустороннем алгоритме в качестве разбиения для строки шаблона используется
критическое разбиение, при этом длина левой подстроки меньше глобального периода всей
строки шаблона ($|u| < per(pattern)$).

В алгоритме используются следующие правила сдвигов:

* При несовпадении в процессе сравнения правой подстроки шаблон сдвигается вправо на
  количество просканированных символов, так, чтобы позиция разбиения шаблона оказалась на
  позиции несовпавшего символа:

  ```goat
            .---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---.                                
            | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |16 |17 |18 |19 |20 |

            .-----------------------------------------------------------------------------------.
      Text: | E   B   C   D   A   C   D   A   B   D   A   B   C   D   A   B   D   D   A   B   D |
            '-----------------------------------------------------------------------------------'
                          правая часть
                         ---------------->
                          ✔   ✔   ✘
             .-------------------------.
  Pattern₁: | A   B   C | D   A   B   D |
             '----------o--------------'
                         '---------.
                                    |
                         .----------v---------------.
  Pattern₂:             | A   B   C | D   A   B   D  |
                         '----------+---------------'
  ```

* При несовпадении в процессе сравнения левой подстроки текст сдвигается на глобальный
    период шаблона $per(pattern)$:

  ```goat
            .---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---.                                
            | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |12 |13 |14 |15 |16 |17 |18 |19 |20 |

            .-----------------------------------------------------------------------------------.
      Text: | E   B   C   D   A   C   D   A   B   D   A   B   C   D   A   B   D   D   A   B   D |
            '-----------------------------------------------------------------------------------'

                          2. левая    1. правая часть
                         <---------- ---------------->
                              ✘   ✔   ✔   ✔   ✔   ✔
                         .--------------------------.
  Pattern₂:             | A   B   C | D   A   B   D  |
                         +----------+---------------'
                         |
                         |
                         |                   .--------------------------.
  Pattern₃:               '---------------->| A   B   C | D   A   B   D  |
                          Сдвиг на per(x)=5  '----------+---------------'
                              символов

  ```

Такие правила сдвигов приводят к квадратичной сложности в худшем случае. Но, для улучшения
асимптотической сложности худшего случая, в алгоритме также используется техника
запоминания префикса (*prefix memorization*): когда производится сдвиг на $per(pattern)$
по правилу сдвига для левой подстроки, то запоминается префикс совпавшей части шаблона,
чтобы не сравнивать его ещё раз в следующем цикле.  
Это та же техника, которая используется в модификации алгоритма Бойера-Мура с добавлением
правила Галиля.

Ниже представлена первый вариант двустороннего алгоритма. Считаем, что период строки шаблона $per(pattern)$ и критическое
разбиение $uv$ с $|u|<per(pattern)$ вычислены заранее.

Код на kotlin, без обработки суррогатных пар.

```kotlin
data class Factorization(val left: IntRange, val right: IntRange)

/**
 * Возвращает позиции всех вхождений шаблона [pattern] в строке [text]
 */
fun cp1(text: String, pattern: String): List<Int> {
    val result = mutableListOf<Int>()

    // factorize() разбивает строку шаблона pattern на 2 подстроки:
    // left и right так, что |left| < period.
    // left, right - закрытые диапазоны индексов соответствующих подстрок
    // period - глобальный период строки шаблона
    val (left, right) = factorize(pattern)
    val period = pattern.getMinimalPeriod()

    var pos = 0
    var memPrefix = -1
    while (pos + pattern.length <= text.length) {
        // Сравнение правой части
        val i = (maxOf(right.first, memPrefix + 1)..right.last).find{ i->
            pattern[i] != text[pos + i]
        }
        if (i != null) {
            pos = pos + i - right.first + 1
            memPrefix = -1
        } else {
            // Сравнение левой части
            val match = (left.last downTo memPrefix + 1).all { j ->
                pattern[j] == text[pos + j]
            }
            if (match) result.add(pos)
            pos += period
            memPrefix = pattern.length - period - 1
        }
    }
    return result
}

```

`memprefix` — позиция запомненного префикса, обновляется при встрече несовпадающих
символов. Может быть установлена в неотрицательное значение только при сканировании левой
подстроки.

Лемма

:   Пусть $uv$ — критическое разбиение строки $x$. Если $w$ — суффикс $u$ и $w$ — префикс
$v$ (базовый случай), то длина $w$ кратна глобальному периоду строки $x$.

Доказательство

:   Свойство тривиально выполняется для пустой строки, в противном случае, так как
$r(u,v)=per(x)$, т.е. $per(x)$ равен периоду строки $w$, то $x$ можно записать как
$(yz)^e$, где $|yz|=per(x)$, $z$ — не пустая, $e>0$. Если $y$ не будет пустой, то $y$
будет повторением для разбиения $uv$. Но $|y|<per(x)$ будет противоречить тому, что $uv$ —
критическое разбиение. Поэтому, $|w|=e*period(x)$.

```goat
                                          period(x)                                                                              
                                         <--------->
   .------------+-----------+-----------+-----------+-----------+-----------+---------------.
   |            |  yz       |      yz   |      yz   |      yz   |      yz   |               |
   '------------+-----------+-----------+-----------+-----------+-----------+---------------'
                            |                       |                       |
                            |                       |                       |
   .------------------------+-----------------------+-----------------------+---------------.
   |                        |           𝒘           |           𝒘           |               |
   '------------------------+-----------------------+-----------------------+---------------'

```

Доказательство корректности алгоритма есть в ["Text Algorithms"][Text-Algorithms]. В таком
виде алгоритм использует максимум $2*|text|$ операций сравнения. (доказательство там же).

Глобальный период строки шаблона требуется только тогда, когда он относительно не большой
(меньше примерно половины длины шаблона), в остальных случаях можно обойтись без его
вычисления.

Второй вариант двустороннего алгоритма рассчитан на применение с большим периодом шаблона.
Дополнительное его преимущество — относительно небольшое максимальное количество
сравнений.

Вариант отличается от первого тем, что в нем больше не используется запоминание префикса,
а при несовпадении в левой подстроке используется другое правило. Шаблон сдвигается не на
$per(pattern)$ позиций, а на количество $q$, которое может быть меньше глобального периода
($q ≤ per(pattern)$).  
Если взять в качестве значения $q=1$, то алгоритм станет аналогичным
наивному алгоритму с квадратичной сложностью, поэтому число $q$ выбирается с
дополнительным ограничением: $q > \max(|u|, |v|)$, где $uv$ — критическое разбиение
$pattern$. С этим ограничением, число сравнений во втором варианте по прежнему будет
меньше $2*|text|$, как и в первом, но вычисление глобального периода не
потребуется.  
Запоминание префикса в данном случае не может быть применено из-за того, что
$q$ может быть меньше $per(pattern)$.

```kotlin
fun twoWay2(text: String, pattern: String): List<Int> {
    val result = mutableListOf<Int>()

    val (left, right) = factorize(pattern)
    val q = maxOf(left.length, right.length) + 1

    var pos = 0
    while (pos + pattern.length <= text.length) {
        // Сравнение правой части
        val i = right.find { i -> pattern[i] != text[pos + i] }
        if (i != null) {
            pos = pos + i - right.first + 1
        } else {
            // Сравнение левой части
            val match = left.reversed().all { j -> pattern[j] == text[pos + j] }
            if (match) result.add(pos)
            pos += q
        }
    }
    return result
}
```

Доказательство корректности и максимального количества сравнений аналогично доказательство
первого варианта и также есть в ["Text Algorithms"][Text-Algorithms].

Конечный двусторонний алгоритм использует оба предыдущих варианта, выбирая нужный в
зависимости от того, является ли левая подстрока суффиксом периодической части правой. В
алгоритме, кроме критического разбиения строки шаблона на $u,v$, где $|u|<per(pattern)$, также
используется заранее вычисленный период только правой подстроки $v$. Его вычисление может
быть произведено без дополнительных затрат одновременно с вычислением критического
разбиения.

```kotlin
data class Factorization(
    val left: IntRange,
    val right: IntRange,
    val rightPeriod: Int
)

fun twoWay(text: String, pattern: String): List<Int> {
    // factorize() разбивает строку шаблона pattern на 2 подстроки:
    // left и right так, что |left| < per(pattern) и вычисляет период правой подстроки.
    // left, right — закрытые диапазоны индексов соответствующих подстрок.
    // rightPeriod — период правой подстроки
    val (left, right, rightPeriod) = factorize(pattern)

    // left — суффикс подстроки right[0..rightPeriod-1]
    val leftIsSuffixOfRight = left.all { i ->
        pattern[i] == pattern[right.first + rightPeriod - left.length + i]
    }
    return if (leftIsSuffixOfRight) {
        // rightPeriod равен периоду строки шаблона per(pattern).
        // Вызываем первый вариант алгоритма, используя left, right
        // и rightPeriod в качестве глобального периода
        cp1(text, pattern, left, right, rightPeriod)
    } else {
        // Вызываем второй вариант алгоритма, используя left, right
        // и q.
        val q = maxOf(left.length, right.length) + 1
        cp2(text, pattern, left, right, q)
    }
}
```

Доказательства корректности алгоритма, а также того, что $q=max(|u|,|v|)+1$ соответствует
условию $q≤per(pattern)$ в случае, если $u$ не является суффикс $v[0…p-1]$, даны в ["Text
Algorithms"][Text-Algorithms].

Алгоритм выполняется за время $O(|text| + |pattern|)$ с константной памятью, при этом
выполняется не более $2*|text|$ сравнений.

Условие "$u\texttt{ — суффикс }v[0…p-1]$" выполняется максимум за $|pattern|/2$
сравнений, вычисление периода и критического разбиения — $4*|pattern|$ сравнений, поэтому
весь препроцессинг выполняется максимум за $4.5*|pattern|$ сравнений.

#### Примеры прохода алгоритма

1\. Возьмем шаблон $pattern=\texttt{A}^n\texttt{B}$. Критическое разбиение: $(\texttt{A}^n,
\texttt{B})$. Поиск в тексте $\texttt{B}^m$ потребует $2*|text|/|pattern|$ сравнений.
Несовпадение встречается в левой части, алгоритм сдвигает шаблон на 3 позиции.
```goat
Text:      B B B B B B B B B B B B B B B B B B B B B B B                                                               

             ✘ ✔
Pattern₁:  A A|B

                   ✘ ✔
Pattern₂:        A A|B

                         ✘ ✔
Pattern₃:              A A|B
```

2\. Шаблон $pattern=\texttt{A}^n\texttt{BA}^n$ с глобальным периодом $n+1$. Критическое
разбиение: $(\texttt{A}^n, \texttt{BA}^n)$. Левая часть — суффикс периодической части
правой, поэтому будет использован первый вариант алгоритма и $2*|text|-2e-2$ сравнений при
поиске в тексте $text=(\texttt{A}^n\texttt{BA})^e\texttt{A}^{n-1}$.
```goat
Text:     A A B A A A B A A A B A A A B A A A B A A A B A                                                              

          ✔ ✔ ✔ ✔ ✔
Pattern₁: A A|B A A

                    ✘
Pattern₂:       A A|B A A

                  ✔ ✔ ✔ ✔ ✔
Pattern₃:         A A|B A A

                            ✘
Pattern₄:               A A|B A A

                          ✔ ✔ ✔ ✔ ✔
Pattern₅:                 A A|B A A
```

3\. Шаблон $pattern=\texttt{A}^n\texttt{BA}^{n-1}$. Алгоритм будет использовать второй
вариант и также выполнит $2*|text|-2e-2$ сравнений при
поиске в тексте $text=(\texttt{A}^n\texttt{BA})^e\texttt{A}^{n-1}$.
```goat
Text:     A A A B A A A B A A A B A A A B A A A B A A A B                                                              

          ✔ ✔ ✔ ✔ ✔ ✔
Pattern₁: A A A|B A A

                  ✔ ✔ ✔ ✔ ✔ ✔
Pattern₂:         A A A|B A A

                          ✔ ✔ ✔ ✔ ✔ ✔
Pattern₃:                 A A A|B A A
```

## Вычисление критического разбиения

Введем дополнительные определения:

__Слово Линдона__

__Циклический сдвиг (вращение)__

Вычисление критического разбиения основывается на доказательстве теоремы о критическом
разбиении: любая строка $x$ имеет хотя бы одно критическое разбиение $x=uv$ (т.е. такое разбиение,
что $r(u,v)=per(x)$).  Более того, подстрока $u$ может быть выбрана такой, что её длина
будет меньше глобального периода строки $x$: $|u|<per(x)$.

У теоремы есть простое доказательство для частного случая, когда верно условие
$3*per(x)<|x|$. В этом случае строку $x$ можно записать как $x=lwwr$, где $|w|=per(x)$ и
$w$ выбирается лексикографически минимальной среди её циклических сдвигов. Т.е. $w$ —
 это слово Линдона и это слово без границ.

Введем отношения порядка слов.

__Лексикографический порядок__

:   *Лексикографический* (или алфавитный) порядок определяется на множестве слов $A^\*$
упорядоченного алфавита *A*. Для двух слов $x, y ∈ A^\*$ слово $x≤y$ тогда, когда
выполняется одно из условий:
    * $x$ — префикс $y$
    * $x$ *строго меньше* $y$. Т. е. $x$ и $y$ можно представить как $x=w\texttt{A}x,
    y=w\texttt{B}y$, где $w,x,y$ — слова  из множества $A^\*$; а $\texttt{A}, \texttt{B}$ ­—
    два символа, такие, что $\texttt{A}<\texttt{B}$.

__Обратный лексикографический порядок__

:   *Обратный лексикографический порядок* — лексикографический порядок на алфавите $A$,
порядок символов которого заменен на обратный. Т.е. $x$ строго меньше $y$, если $x$ и $y$
можно представить как $x=w\texttt{A}x, y=w\texttt{B}y$, где $w,x,y$ — слова  из алфавита
$A^\*$, а $\texttt{A}, \texttt{B}$ ­— два символа, такие, что $\texttt{A}>\texttt{B}$.

Обозначим через $≤$ прямой лексикографический порядок, а через $⪯$ — обратный.

Ниже представлены все суффиксы строки $\texttt{ABAABAA}$, отсортированные в прямом и
обратном порядке:

```textinline
  Суффиксы        ≤                ⪯
ABAABAA         A                BAA
BAABAA          AA               BAABAA
AABAA           AABAA            A
ABAA            ABAA             ABAA
BAA             ABAABAA          ABAABAA
AA              BAA              AA
A               BAABAA           AABAA
```

Стоит отметить, что порядок $≤$ — не инверсия порядка $⪯$. Например, возьмем алфавит
$A=\\{\texttt{A},\texttt{B}\\}$ с $\texttt{A} < \texttt{B}$. Для слов $\tt ABB$ и $\tt
ABBAA$ верны оба равенства:
* $\texttt{ABB} ≤ \texttt{ABBAA}$
* $\texttt{ABB} ⪯ \texttt{ABBAA}$

Более того, в пересечении порядков $≤$ и $⪯$ совпадает только первое условие префикса.
Т.е.оба выражения $x ≤ y$ и $x ⪯ y$ верны только в том случае, если $x$ — префикс $y$.

__Максимальный суффикс__

:   *Максимальный суффикс* — это наибольшая подстрока слова $x$ в соотвествии с
заданным лексикографическим порядком. Обозначим его через $Maxsuf(x)$.

__Теорема__

Пусть $x$ ­— непустая строка из символов алфавита $A$ и $x=uv=u'v'$, где $v$ ­—
лексикографически максималный суффикс строки $x$ в соответствии с прямым порядком ($≤$), а
$v'$ — лексикографически максимальный суффикс $x$ в соответсвтии с обратным порядком (⪯).  
Если $|v|≤|v'|$, то $uv$ — критическое разбиение $x$, а иначе $u'v'$ — критическое
рабзиение $x$. Более того, $|u|<per(x)$ и $|u'|<per(x)$.

Доказательство дано в ["Text Algorithms"][Text-Algorithms]

Имея эту теорему, задача нахождения критического разбиения сводится к задаче нахождения
максимального суффикса, а точнее, к вычислению максимального суффикса для прямого и обратного
алфавитного порядка.

```kotlin
data class Factorization(
    val left: IntRange,
    val right: IntRange,
    val rightPeriod: Int
)

fun factorize(pattern: String): Factorization {
    val naturalOrder = computeMaxSuffixAndPeriod(pattern, naturalOrder())
    val reverseOrder = computeMaxSuffixAndPeriod(pattern, reverseOrder())
    return if (naturalOrder.right.length <= reverseOrder.right.length)
        naturalOrder else reverseOrder
}

fun computeMaxSuffixAndPeriod(pattern: String, 
                              comparator: Comparator<Char>): Factorization…
```
`computeMaxSuffixAndPeriod()` — функция, вычисляющая максимальный суффикс и период правой
подстроки.

__Пример 1:__

Шаблон $pattern=\tt \underlinesegment{ABA}\underlinesegment{ABA}\underlinesegment{A\space\space\space}$  
Период строки: $p=3$  
Максимальный суффикс для алфавитного порядка $≤$: $\tt BAABAA$  
Разбиение для алфавитного порядка: $(\texttt{A}, \texttt{BAABAA})$.

Максимальный суффикс для обратного порядка $⪯$: $\tt AABAA$  
Разбиение для обратного порядка: $(\texttt{AB}, \texttt{AABAA})$.

Разбиение для прямого порядка — не критическое, его локальный период = 2 ($\texttt{BA}$).
Разбиение для обратного порядка — критическое.

__Пример 2:__

Шаблон $pattern=\tt \underlinesegment{ABABAABB}\underlinesegment{ABABA\space\space\space\space}$  
Период строки: $p=8$  
Максимальный суффикс для алфавитного порядка $≤$: $\tt BBABABA$  
Разбиение для алфавитного порядка: $(\texttt{ABABAA}, \texttt{BBABABA})$.

Максимальный суффикс для обратного порядка $⪯$: $\tt AABBABABA$  
Разбиение для обратного порядка: $(\texttt{ABAB}, \texttt{AABBABABA})$.

Оба разбиения критические.

Алгоритм вычисления максимального суффикса основан на использовании декомпозииции Линдона.

```kotlin
fun computeMaxSuffixAndPeriod(pattern: String, comparator: Comparator<in Char>): Factorization {
    var maxSuffix = -1
    var j = 0
    var k = 1
    var period = 1
    while (j + k < pattern.length) {
        val a = pattern[j + k]
        val b = pattern[maxSuffix + k]
        val abOrder = comparator.compare(a, b)
        when {
            // a < b
            abOrder < 0 -> {
                j += k
                k = 1
                period = j - maxSuffix

            // a == b
            abOrder == 0 -> {
                if (k != period) {
                    k += 1
                } else {
                    j += period
                    k = 1
                }

            // a > b
            else ->  {
                maxSuffix = j
                j = maxSuffix + 1
                k = 1
                period = 1
            }
        }
    }
    return Factorization(0 .. maxSuffix,
        maxSuffix + 1 .. pattern.lastIndex,
        period
    )
```

Обозначим через $Maxsuf(x)$ максимальный суффикс строки $x$ в соответствии с алфавитным
порядком.  
Пусть $$Maxsuf(x)=f^eg$$ где $f$, $g$ — подстроки;  
<nobr>$|f|=per(Maxsuf(x))$</nobr>, т.е. длина $f$ — это период строки макс. суффикса;  
$g$ — собственный префикс подстроки $f$;  
$e$ — целое число $e>0$.  
Обозначим $$Per(x)=f; \hspace{1em} Rest(x)=g$$
Отметим, что $Rest(x)$ — это грань строки $Maxsuff(x)$ и $Border(Maxsuf(x))=f^{e-1}g$, даже при $e=1$.

Переменная `maxSuffix` в алгоритме — позиция перед первым символом рассматриваемой строки
максимального суффикса.  
`period` — период строки максимального суффикса, длина $Per(x)$.  
`j` … `j+k` — подстрока в $Maxsuf(x)$ последнеднего встреченного вхождения $Rest(x)$ в
подстроке максимального суффикса.

```goat
                   .-------------------------------------------------------------------.                                      
                   |              Maxsuf(x)                                            |
                   '-------------------------------------------------------------------'
                   :
  .------------+---+----------+---+----------------------------------------------------+---+-------.
x |            |   |          | a'|                                         :          | a |       |
  '------------+---+----------+---+----------------------------------------------------+---+-------'
                ms :          :                                             :j         :j+k
                   :          :                                             :          :
                   .------------------.                  .------------------+----------.
                   |  Period(x)       |  …  …  …   …  …  | Period(x)        | Rest(x)  |
                   '------------------'                  '------------------+----------'
                   :          :ms+k
                   .----------.
                   | Rest(x)  |
                   '----------'
```

Алгоритм выполняется за время $O(|pattern|)$, при этом выполняется менее $2*|pattern|$
сравнений.

Рассмотрим на примере, как изменяется максимальный суффикс строки $x$ при добавлении в её
конец символов $\texttt{A}, \texttt{B}\text{ и }\texttt{C}$.  
Пусть $x=\tt ABCBCBACBCBACBC.$  
В соответствии с алфавитным порядком её максимальный суффикс равен
$Maxsuf(x)=\texttt{CBCBACBCBACBC}=(\texttt{CBCBA})²\texttt{CBC}$.

Для строки $x\texttt{A}$ макс. суффикс: $\tt CBCBACBCBACBCA$ = $Maxsuf(x)\texttt{A}$. Слово
без границ.  
Для строки $x\texttt{B}$ макс. суффикс: $\tt CBCBACBCBACBCB$ = $Maxsuf(x)\texttt{B}$. У
слова такой же период, как и у $Maxsuf(x)$.  
Для строки $x\texttt{C}$ макс. суффикс: $\tt CC$.

Доказательство корректности алгоритма основывается на следующей леммме.

Возьмем строку $x$ и символ $\tt A$. Пусть $\texttt{A}'$ — такой символ, что
$Rest(x)\texttt{A}'$ — это перфикс $Maxsuf(x)$. Тогда значения 
$Maxsuf(x\texttt{A}), Per(x\texttt{A}), Rest(x\texttt{A})$ будут равны следующим:

| __Условие__ | $\bf Maxsuf(x\texttt{A})$ | $\bf Per(x\texttt{A})$ | $\bf Rest(x\texttt{A})$ |
| - | - | - | - |
| $\texttt{A} < \texttt{A}'$ | $Maxsuf(x)\texttt{A}$ | $Maxsuf(x)\texttt{A}$ | $ε$ |
| $\texttt{A} = \texttt{A}'$ | $Maxsuf(x)\texttt{A}$ | $Per(x)$ | $Rest(x)\texttt{A}$, либо $ε$ |
| $\texttt{A} > \texttt{A}'$ | $Maxsuf(Rest(x)\texttt{A})$ | $Per(Rest(x)\texttt{A})$ | $Rest(Rest(x)\texttt{A})$ |

Доказательство дано в "[Text Algorithms][Text-Algorithms]".

## Реализация алгоритма

Ниже приведена полная реализация алгоритма (на Kotlin, без учета суррогантых пар).

```kotlin
internal data class Factorization(
    val pattern: String,
    val left: IntRange,
    val right: IntRange,
    val rightPeriod: Int
) {
    fun leftIsSuffixOfRight(): Boolean {
        return left.all { i -> pattern[i] == pattern[right.first + rightPeriod - left.length + i] }
    }
}

fun findSubstringTwoWay(text: String, pattern: String): List<Int> {
    when {
        text.isEmpty() -> return emptyList()
        pattern.isEmpty() -> return text.indices.toList()
    }

    val result: MutableList<Int> = mutableListOf()

    val factorization = factorize(pattern)
    if (factorization.leftIsSuffixOfRight()) {
        // CP1
        val (_, left, right, period) = factorization
        var pos = 0
        var memPrefix = -1
        while (pos + pattern.length <= text.length) {
            // Сравнение правой части
            val i = (maxOf(right.first, memPrefix + 1)..right.last).find { i ->
                pattern[i] != text[pos + i]
            }
            if (i != null) {
                pos = pos + i - right.first + 1
                memPrefix = -1
            } else {
                // Сравнение левой части
                val match = (left.last downTo memPrefix + 1).all { j ->
                    pattern[j] == text[pos + j]
                }
                if (match) result.add(pos)
                pos += period
                memPrefix = pattern.length - period - 1
            }
        }
    } else {
        // CP2
        val left = factorization.left.reversed()
        val right = factorization.right
        val q = maxOf(left.length, right.length) + 1
        var pos = 0
        while (pos + pattern.length <= text.length) {
            // Сравнение правой части
            val i = right.find { i -> pattern[i] != text[pos + i] }
            if (i != null) {
                pos = pos + i - right.first + 1
            } else {
                // Сравнение левой части
                val match = left.all { j -> pattern[j] == text[pos + j] }
                if (match) result.add(pos)
                pos += q
            }
        }
    }
    return result
}

private fun factorize(pattern: String): Factorization {
    val naturalOrder = computeMaxSuffixAndPeriod(pattern, naturalOrder())
    val reverseOrder = computeMaxSuffixAndPeriod(pattern, reverseOrder())
    return if (naturalOrder.right.length <= reverseOrder.right.length)
        naturalOrder else reverseOrder
}

internal fun computeMaxSuffixAndPeriod(pattern: String,
                                       comparator: Comparator<in Char>): Factorization {
    var maxSuffix = -1
    var j = 0
    var k = 1
    var period = 1
    while (j + k < pattern.length) {
        val a = pattern[j + k]
        val b = pattern[maxSuffix + k]
        val abOrder = comparator.compare(a, b)
        when {
            // a < b
            abOrder < 0 -> {
                j += k
                k = 1
                period = j - maxSuffix
            }

            // a == b
            abOrder == 0 -> {
                if (k != period) {
                    k += 1
                } else {
                    j += period
                    k = 1
                }
            }

            // a > b
            else -> {
                maxSuffix = j
                j = maxSuffix + 1
                k = 1
                period = 1
            }
        }
    }
    return Factorization(
        pattern,
        0..maxSuffix,
        maxSuffix + 1..pattern.lastIndex,
        period
    )
}
```

## Источники

* CROCHEMORE, M., RYTTER, W., 1994, Text Algorithms, Oxford University Press. ([ссылка][Text-Algorithms])
* CROCHEMORE M., PERRIN D., 1991, Two-way string-matching, Journal of the ACM
  38(3):651-675. ([ссылка][CP-1991-jacm.pdf])
* Wikipedia: Two-way string-matching algorithm ([ссылка][Wikipedia_TwoWay]).
* Викиконспекты ИТМО: Двусторонний алгоритм ([ссылка][Itmo_TwoWay]).
* Кутенин Данила М., 2019. Умные алгоритмы обработки строк в ClickHouse ([ссылка][Kutelin_clickhouse]).

[^1]: [Two-Way String-Matching, MAXIME CROCHEMORE AND DOMINIQUE
    PERRIN][CP-1991-jacm.pdf]

[Text-Algorithms]: https://www-igm.univ-mlv.fr/~mac/REC/B1.html
[CP-1991-jacm.pdf]: https://monge.univ-mlv.fr/~mac/Articles-PDF/CP-1991-jacm.pdf
[Wikipedia_TwoWay]: https://en.wikipedia.org/wiki/Two-way_string-matching_algorithm
[Itmo_TwoWay]: http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B2%D1%83%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D0%B8%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC
[Kutelin_clickhouse]: https://www.hse.ru/edu/vkr/296308510

[glibc]: https://github.com/bminor/glibc/blob/a01a13601c95f5d111d25557656d09fe661cfc89/string/strstr.c#L74
[newlib]: https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/string/memmem.c;h=65267b9c5e52b15db86feec5b7a511d927ec469a;hb=HEAD#l112
[musl]: https://git.musl-libc.org/cgit/musl/tree/src/string/strstr.c#n33
